# Как это работает?

Определим свой глагол `nxt`, вычисляющий одну итерацию look-and-say:

		nxt=:3 : 0
			b=.1,-.=/"1 (2]\y)
			l=.b #;.1 y
            c=.b {.;.1 y
            ,/ |: (2,#c) $ l,c
		)
		# nxt^:50 '0123456789' i. '1113222113'

Первая строка — объявление нового глагола nxt. `=:` — символ присваивания. `3 : 0` означает, что он будет только монадой. Тело глагола заканчивается закрывающей круглой скобкой, а единственный правый аргумент глагола обозначается `y`

## Часть 1

    b=.1,-.=/"1 (2]\y)

b — это вектор 0 и 1, 1 стоят у на позициях, с которых начинается очередной сегмент одинаковых символов.
Например, для исходной строки 1 1 1 3 2 2 2 1 1 3 результат будет 1 0 0 1 1 0 0 1 0 1

Как это работает поглагольно:
1. `b=.` — присваивание новой переменной b
2. `1,<list>` — список <list>, к которому вначало приписали единичку.
3. `-.<list>` — булево отрицание каждого элемента списка
4. `=/"1<list>` — интерпретирует каждый элемент из списка `list`, как список и запускает на нем глагол проверки на равенство `=/`.
5. `2]\y` — все биграммы списка y. Тут  наречие `2 <u> \` применяет глагол u ко всем биграммам, а ] не делает ничего.

## Часть 2

	l=.b #;.1 y

l — это список длин сегментов одинакых символов. На исходном примере — 3 1 3 2 1. Как работает?

1. Наречие `x u ;.1 y` разбивает y в тех местах, где у x стоят единички на интервалы и к каждому применяет глагол u.
2. Глагол `#` возвращает длину списка

## Часть 3

	c=.b {.;.1 y

с — это список первых символов каждого сегмента. На исходном примере — 1 3 2 1 3. 

Работает аналогично предыдущей строке, только вместо глагола `#` используется глагол `{.` (Head) получение первого элемента списка.

## Часть 4
  
    ,/ |: (2,#c) $ l,c
    
На этом этапе нужно почередовать элементы из l и c. Это делается так:
1. `l,c` — конкатенируем l и c
2. `(2, #c) $ l,c` — меняем форму списка на матрицу, в которой 2 строки. l попадает в первую строку, с — во вторую. 
3. `|:` — транспонируем матрицу. Теперь если прочитать матрицу построчно, то получим ответ.
4. `,/` — объединяем все строки в один список. PROFIT!
 

## Часть 5

    '0123456789' i. '1113222113'

Эта часть делает из строкисписок чисел. `i.` для каждого символа в правом аргументе ищет индекс этого символа в левом аргументе. (а строки — это списки символов, поэтому к ним можно применять глаголы работающие со списками)

## Часть 6
    
    nxt^:50 <list>
50 раз вызываем nxt с помощью `u ^: n` Fixed Power.
